# vim:fileencoding=utf-8
# License: GPL v3 Copyright: 2023, DO LE DUY <duy.dole.00ece at gmail.com>

'''
The key difference between an ePub with SMIL audio synchronization (EPUB3 with Media Overlays) and a regular ePub is the inclusion of SMIL files and audio content:

SMIL Files: ePub with SMIL includes SMIL (Synchronized Multimedia Integration Language) files, XML documents that define audio and text synchronization.

Audio Content: It contains audio files that match eBook sections, referenced in SMIL files for synchronized playback.

Text Content: The textual content, often in HTML or XHTML files, remains similar to regular ePub. Text and audio are linked using <span> tags with unique IDs.

SMIL, audio, and text files are organized into folders, usually inside the epub/ or OEBPS/ folder. Sometimes, SMIL files may be placed in text folders. In this program we assume that each spoken text file corresponds to one audio file and one SMIL file.  

Public domain audio eBooks can be found on https://www.readbeyond.it/ebooks.html. ReadBeyond also offers Aeneas (https://github.com/readbeyond/aeneas), an open-source tool for force-alignment of audio and text to generate smil files. Another notable tool is https://github.com/r4victor/syncabook, builds upon Aeneas to complete a workflow for creating EPUB3 with Media Overlays.

'''

from __python__ import bound_methods, hash_literals

from elementmaker import E

from book_list.globals import get_session_data
from dom import svgicon, unique_id
from gettext import gettext as _
from read_book.globals import runtime, ui_operations, current_spine_item, current_book
from read_book.highlights import ICON_SIZE
from read_book.selection_bar import BUTTON_MARGIN, get_margins, map_to_iframe_coords
from read_book.shortcuts import shortcut_for_key_event

HIDDEN = 0
PAUSED = 1
PLAYING = 2


class ReadAudioEbook:
    
    dont_hide_on_content_loaded = True

    def __init__(self, view):
        self.view = view
        self.parser = new window.DOMParser()
        self._state = HIDDEN
        self.bar_id = unique_id("bar")
        
        container = self.container
        container.setAttribute("tabindex", "0")
        container.appendChild(E.div(
            id=self.bar_id,
            style="position: absolute; bottom: 0; width: 90%; height: 2em; border-radius: 1em; padding:0.5em; display: flex; justify-content: center; align-items: center; background-color: rgba(51, 51, 51, 0.4); border: 1px solid rgba(255, 255, 255, 0.2); "
        )) 
        
        container.addEventListener("keydown", self.on_keydown, {"passive": False})
        container.addEventListener("click", self.container_clicked, {"passive": False})
        container.addEventListener("contextmenu", self.toggle, {"passive": False})
        document.addEventListener("scroll", self.on_scrolled, {"passive": False})

        bar_container = self.bar = document.getElementById(self.bar_id)

        if self.state is PLAYING:
            bar_container.classList.add("speaking")
        else:
            bar_container.classList.remove("speaking")

        def cb(name, icon, text):
            ans = svgicon(icon, ICON_SIZE, ICON_SIZE, text)
            if name:
                ans.addEventListener("click", def(ev):
                    ev.stopPropagation(), ev.preventDefault()
                    self[name](ev)
                    self.view.focus_iframe()
                )
            ans.classList.add("simple-link")
            ans.style.marginLeft = ans.style.marginRight = BUTTON_MARGIN
            return ans

        for x in [
            E.div (
                style='height: 3ex; display: flex; align-items: center; justify-content: center',
                cb("pause", "pause", _("Pause audio")),
                cb("play", "play", _("Play audio")),
                cb("overlay", "cogs", _("Toggle overlay")),
            ),
            E.div(
                id="timeDisplay",
                E.text("")
            ),
            E.div(
                id="progressBar",
                style="height:1.5em; display:block; background-color:rgba(255, 255, 255, 0.7); width:70%; margin:1em",
                E.div(
                style="display:block; background-color:rgba(0, 0, 0, 0.9); height:100%")
            ),
            E.div(
                style='height: 3ex; display: flex; align-items: center; justify-content: center',
                cb("slower", "slower", _("Slow down speech")),
                cb("faster", "faster", _("Speed up speech")),
                cb("hide", "close", _("Close Read aloud"))
            )
            
        ]:
            bar_container.appendChild(x)

        self.progressBar = document.getElementById("progressBar") 
        self.timeDisplay = document.getElementById("timeDisplay")

        self.audio_id = unique_id("audio")
        self.container.appendChild(E.audio(
            id=self.audio_id,
            src="",
            # src="book/OEBPS/Audio/01.mp3",
            # src="book/OEBPS" + audioFile[1:],
            # src=clbr://internal.sandbox/book/OEBPS/Audio/01.mp3
            style="display:none"
        )) 

        self.audioplayer = document.getElementById(self.audio_id) 

        self.audioplayer.addEventListener("play", def():
            self.audioMap = self.audioMaps[current_spine_item()]
            self.send_message("mark", spanID = self.spanID)
        )

        self.audioplayer.addEventListener("timeupdate", def():
            audioCurrentTime = self.audioplayer.currentTime
            progress = (audioCurrentTime / self.audioplayer.duration) * 100
            self.progressBar.firstChild.style.width = progress + "%"
            self.timeDisplay.textContent = f"{self.secondsToMS(audioCurrentTime)}/{self.secondsToMS(self.audioplayer.duration)}"
            if self.state == PLAYING:
                spanID = self.findSpanIDForTime(audioCurrentTime)  
                if spanID != self.spanID:
                    old_spanID = self.spanID
                    self.spanID = spanID
                    self.send_message("mark", old_spanID=old_spanID, spanID = self.spanID)
        )

        self.progressBar.addEventListener("click", def(event):
            rect = self.progressBar.getBoundingClientRect()
            clickX = event.clientX - rect.left
            totalWidth = rect.width
            skipTime = (clickX / totalWidth) * self.audioplayer.duration
            self.audioplayer.currentTime = skipTime
        )

        self.audioplayer.addEventListener("ended", def():
            view.show_next_spine_item()
        )    


    def parse_smil_file(self, smil_content, smil_name, mimetype):
        # Extract information from the parsed XML
        xmlDoc = self.parser.parseFromString(smil_content, "text/xml")
        audioMap = {}
        # audioFiles = set()

        parElements = xmlDoc.getElementsByTagName("par")

        audioElement = parElements[0].getElementsByTagName("audio")[0]
        audioFile = audioElement.getAttribute("src")

        for parElement in parElements:
            textElement = parElement.getElementsByTagName("text")[0]
            audioElement = parElement.getElementsByTagName("audio")[0]
            if textElement and audioElement:
                spanID = textElement.getAttribute("src").split("#")[1]
                audioDetails = {
                    "clipBegin": audioElement.getAttribute("clipBegin"),
                    "clipEnd": audioElement.getAttribute("clipEnd")
                }
                audioMap[spanID] = audioDetails
                # audioFiles.add(audioElement.getAttribute("src"))

        self.audioMaps[smil_name[:-5].replace("smil", "text")] = [audioMap, audioFile]
        

    def change_audio_src(self):

        if self.audioMaps[current_spine_item()]:
            self.send_message("mark", spanID = self.spanID)
            self.audioMap = self.audioMaps[current_spine_item()]

            link = self.audioFiles[0].split("/")[0] + self.audioMaps[current_spine_item()][1][2:]

            # print(link)
            # ui_operations.get_file(
            #     current_book(), link, def(blob, name, mimetype):
            #         blob = new window.Blob([blob], {"type": "audio/mpeg"})
            #         blobURL = window.URL.createObjectURL(blob)
            #         self.audioplayer.src = blobURL
            #         self.play()
            #         self.send_message("play")
            # )
            # TODO More logics to handle unexpected folder structures
            # TODO Prove src for Calibre content server viewer

            self.audioplayer.src = "book/" + link
            self.play()
            self.send_message("play")

        else:
            self.audioplayer.src = ""
            self.view.show_next_spine_item()
            

    @property
    def container(self):
        return document.getElementById("audio-ebooks-overlay")

    @property
    def supports_css_min_max(self):
        return not runtime.is_standalone_viewer or runtime.QT_VERSION >= 0x050f00

    @property
    def is_visible(self):
        return self.container.style.display is not "none"

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, val):
        if val is not self._state:
            self._state = val


    def hide(self):
        if self.state is not HIDDEN:
            self.send_message("mark", old_spanID=self.spanID)
            self.pause()
            self.container.style.display = "none"
            self.view.focus_iframe()
            self.state = HIDDEN
            if ui_operations.read_aloud_state_changed:
                ui_operations.read_aloud_state_changed(False)

    def show(self):
        if self.state is HIDDEN:
            self.change_audio_src()
            self.container.style.display = "block"
            self.focus()
            self.state = PAUSED
            if ui_operations.read_aloud_state_changed:
                ui_operations.read_aloud_state_changed(True)

    def focus(self):
        self.container.focus()

    def slower(self):
        self.audioplayer.playbackRate -= 0.1
        
    def faster(self):
        self.audioplayer.playbackRate += 0.1

    def play(self):
        self.audioplayer.play()
        self.state = PLAYING

    def pause(self):
        self.audioplayer.pause()
        self.state = PAUSED

    def toggle(self):
        if self.state is PLAYING:
            self.pause()
        elif self.state is PAUSED:
            self.play()

    def overlay(self):
        if self.overlay_off:
            self.overlay_off = False
            self.container.style.height = "calc(100% - 1em)"
        else:
            self.overlay_off = True
            self.container.style.height = "3ex"
            
    def container_clicked(self, ev):
        self.play()
        if ev.button is not 0:
            return
        ev.stopPropagation(), ev.preventDefault()
        margins = get_margins()
        pos = {"x": ev.clientX, "y": ev.clientY}
        pos = map_to_iframe_coords(pos, margins)
        self.send_message("play", pos=pos)

    def on_keydown(self, ev):
        ev.stopPropagation(), ev.preventDefault()
        if ev.key is "Escape":
            self.hide()
            return
        if ev.key is " " or ev.key is "MediaPlayPause" or ev.key is "PlayPause":
            self.toggle()
            return
        if ev.key is "Play" or ev.key is "MediaPlay":
            self.play()
            return
        if ev.key is "Pause" or ev.key is "MediaPause":
            self.pause()
            return
        sc_name = shortcut_for_key_event(ev, self.view.keyboard_shortcut_map)
        if not sc_name:
            return
        if sc_name is "show_chrome":
            self.hide()
        elif sc_name is "quit":
            self.hide()
        elif sc_name in ("up", "down", "pageup", "pagedown", "left", "right"):
            self.send_message("trigger-shortcut", name=sc_name)
    
    def findSpanIDForTime(self, currentTime):
        if self.audioMap:
            for spanID in self.audioMap[0]:
                clipBeginTime = self.convertTimeToSeconds(self.audioMap[0][spanID]["clipBegin"])
                clipEndTime = self.convertTimeToSeconds(self.audioMap[0][spanID]["clipEnd"])               
                if clipBeginTime <= currentTime < clipEndTime:
                    return spanID
        return None

    def convertTimeToSeconds(self, timeString):
        parts = timeString.split(":")
        if len(parts) != 3:
            return 0
        hours, minutes, seconds = map(float, parts)
        return hours * 3600 + minutes * 60 + seconds

    def secondsToMS(self, seconds):
        minutes = Math.floor(seconds / 60)
        remainingSeconds = int(seconds % 60)
        return str(minutes) + ':' + (str(remainingSeconds).zfill(2))


    def send_message(self, type, **kw):
        self.view.iframe_wrapper.send_message("audio_ebook", type=type, **kw)

    def handle_message(self, msg):
        if msg.type is "container-clicked":
            if msg.spanID:
                self.audioplayer.currentTime = self.convertTimeToSeconds(self.audioMap[0][msg.spanID]["clipBegin"])
