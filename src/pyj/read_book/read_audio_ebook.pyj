# vim:fileencoding=utf-8
# License: GPL v3 Copyright: 2023, DO LE DUY <duy.dole.00ece at gmail.com>


# The key difference between an ePub with SMIL audio synchronization (EPUB3 with Media Overlays) and a regular ePub is the inclusion of SMIL files and audio content:

# SMIL Files: ePub with SMIL includes SMIL (Synchronized Multimedia Integration Language) files, XML documents that define audio and text synchronization.

# Audio Content: It contains audio files that match eBook sections, referenced in SMIL files for synchronized playback.

# Text Content: The textual content, often in HTML or XHTML files, remains similar to regular ePub. Text and audio are linked using <span> tags with unique IDs.

# SMIL, audio, and text files are organized into folders, usually inside the epub/ or OEBPS/ folder. Sometimes, SMIL files may be placed in text folders. In this program we assume that each spoken text file corresponds to one audio file and one SMIL file.  

# Public domain audio eBooks can be found on https://www.readbeyond.it/ebooks.html. ReadBeyond also offers Aeneas (https://github.com/readbeyond/aeneas), an open-source tool for force-alignment of audio and text to generate smil files. Another notable tool is https://github.com/r4victor/syncabook, builds upon Aeneas to complete a workflow for creating EPUB3 with Media Overlays.


from __python__ import bound_methods, hash_literals

from elementmaker import E

from book_list.globals import get_session_data
from dom import svgicon, unique_id, change_icon_image
from gettext import gettext as _
from book_list.theme import get_color
from read_book.globals import runtime, ui_operations, current_spine_item, current_book
from read_book.highlights import ICON_SIZE
from read_book.selection_bar import BUTTON_MARGIN, get_margins, map_to_iframe_coords
from read_book.shortcuts import shortcut_for_key_event



class ReadAudioEbook:
    
    dont_hide_on_content_loaded = True

    def __init__(self, view):
        self.view = view
        self.parser = new window.DOMParser()
        self._state = "HIDDEN"
        self.bar_id = unique_id("bar")
        
        container = self.container
        container.setAttribute("tabindex", "0")
        container.appendChild(E.div(
            id=self.bar_id,
            style="position: absolute; bottom: 0; width: 90%; height: 2em; border-radius: 1em; padding:0.5em; display: flex; justify-content: center; align-items: center; background-color: rgba(127, 127, 127, 0.3); "
        )) 
        container.addEventListener("keydown", self.on_keydown, {"passive": False})
        container.addEventListener("click", self.on_container_clicked, {"passive": False})
        container.addEventListener("contextmenu", self.toggle, {"passive": False})

        bar_container = self.bar = document.getElementById(self.bar_id)

        def create_button(name, icon, text):
            ans = svgicon(icon, ICON_SIZE, ICON_SIZE, text)
            if name:
                ans.addEventListener("click", def(ev):
                    ev.stopPropagation(), ev.preventDefault()
                    self[name](ev)
                    self.view.focus_iframe()
                )
            ans.id = "audio-ebook-bt-" + name
            ans.classList.add("simple-link")
            ans.style.marginLeft = ans.style.marginRight = BUTTON_MARGIN
            return ans

        for x in [
            E.div (
                id="audioButtons",
                style='height: 3ex; display: flex; align-items: center; justify-content: center',
                create_button("toggle", "pause", _("Pause audio")),
                create_button("overlay", "overlay-off", _("Toggle overlay")),
            ),
            E.div(
                id="timeDisplay",
                E.text("")
            ),
            E.div(
                id="progressBar",
                style="height:1.5em; display:block; background-color:rgba(255, 255, 255, 0.7); width:70%; margin:1em",
                E.div(
                style="display:block; background-color:rgba(0, 0, 0, 0.3); height:100%")
            ),
            E.div(
                style='height: 3ex; display: flex; align-items: center; justify-content: center',
                create_button("slower", "slower", _("Slow down speech")),
                create_button("faster", "faster", _("Speed up speech")),
                create_button("hide", "off", _("Close Read aloud"))
            )
            
        ]:
            bar_container.appendChild(x)

        self.audioButtons = document.getElementById("audioButtons") 
        self.progressBar = document.getElementById("progressBar") 
        self.timeDisplay = document.getElementById("timeDisplay")

        self.audio_id = unique_id("audio")
        self.container.appendChild(E.audio(
            id=self.audio_id,
            style="display:none"
        )) 

        self.audioplayer = document.getElementById(self.audio_id) 

        self.audioplayer.addEventListener("play", def():
            self.audioMap = self.audioMaps[current_spine_item()]
            self.send_message("mark", spanID = self.spanID)
        )

        self.audioplayer.addEventListener("timeupdate", def():
            if self.state != "HIDDEN":
                if self.audioplayer.duration:
                    audioCurrentTime = self.audioplayer.currentTime

                    progress = (audioCurrentTime / self.audioplayer.duration) * 100
                    self.progressBar.firstChild.style.width = progress + "%"

                    self.timeDisplay.textContent = f"{self.secondsToMS(audioCurrentTime)}/{self.secondsToMS(self.audioplayer.duration)}"

                    spanID = self.findSpanIDForTime(audioCurrentTime)
                    if spanID != self.spanID:
                        old_spanID = self.spanID
                        self.spanID = spanID
                        self.send_message("mark", old_spanID=old_spanID, spanID = self.spanID)
                else:
                    self.timeDisplay.textContent = "00:00"
                    self.progressBar.firstChild.style.width = "0%"

        )

        self.audioplayer.addEventListener("ended", def():
            self.view.show_next_spine_item()
        )  

        self.progressBar.addEventListener("click", def(event):
            rect = self.progressBar.getBoundingClientRect()
            clickX = event.clientX - rect.left
            totalWidth = rect.width
            skipTime = (clickX / totalWidth) * self.audioplayer.duration
            self.audioplayer.currentTime = skipTime
        )


    def parse_smil_file(self, smil_content, smil_name, mimetype):
        # Extract information from the parsed XML
        # In content server viewer, the smil file is uploaded as blob
        smil_content.text().then(def(data): 
            xmlDoc = self.parser.parseFromString(data, "text/xml")
            audioMap = {}
            parElements = xmlDoc.getElementsByTagName("par")

            audioElement = parElements[0].getElementsByTagName("audio")[0]
            audioFile = audioElement.getAttribute("src")

            for parElement in parElements:
                textElement = parElement.getElementsByTagName("text")[0]
                audioElement = parElement.getElementsByTagName("audio")[0]
                if textElement and audioElement:
                    spanID = textElement.getAttribute("src").split("#")[1]
                    audioDetails = {
                        "clipBegin": audioElement.getAttribute("clipBegin"),
                        "clipEnd": audioElement.getAttribute("clipEnd")
                    }
                    audioMap[spanID] = audioDetails

            self.audioMaps[smil_name[:-5].replace("smil", "text")] = [audioMap, audioFile]
        )

    def change_audio_src(self):
        if self.audioMaps[current_spine_item()]:
            self.audioMap = self.audioMaps[current_spine_item()]
            link = self.audioFiles[0].split("/")[0] + self.audioMaps[current_spine_item()][1][2:]

            ui_operations.get_file(
                current_book(), link, def(blob, name, mimetype):
                    # blob = new window.Blob([blob], {"type": "audio/mpeg"})
                    blobURL = window.URL.createObjectURL(blob)
                    self.audioplayer.src = blobURL
                    print(blobURL)
                    self.pause()
                    self.send_message("play")
            )

            # self.pause()
            # self.audioplayer.src = "book/" + link
            # self.send_message("play")

        else:
            self.audioplayer.src = ""
            self.view.show_next_spine_item()

    @property
    def container(self):
        return document.getElementById("audio-ebooks-overlay")

    @property
    def supports_css_min_max(self):
        return not runtime.is_standalone_viewer or runtime.QT_VERSION >= 0x050f00

    @property
    def is_visible(self):
        return self.container.style.display is not "none"

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, val):
        if val is not self._state:
            self._state = val

    def hide(self):
        if self.state is not "HIDDEN":
            self.send_message("mark", old_spanID=self.spanID)
            self.pause()
            self.container.style.display = "none"
            self.view.focus_iframe()
            self.state = "HIDDEN"
            if ui_operations.read_aloud_state_changed:
                ui_operations.read_aloud_state_changed(False)

    def show(self):
        if self.state is "HIDDEN":
            self.state = "PLAYING"
            self.change_audio_src()
            self.container.style.display = "block"
            self.focus()
            if ui_operations.read_aloud_state_changed:
                ui_operations.read_aloud_state_changed(True)

    def focus(self):
        self.container.focus()

    def slower(self):
        self.audioplayer.playbackRate -= 0.1
        
    def faster(self):
        self.audioplayer.playbackRate += 0.1

    def play(self):
        if self.audioplayer.src:
            self.audioplayer.play()
        self.state = "PLAYING" 
        change_icon_image(document.getElementById("audio-ebook-bt-toggle"), "pause")

    def pause(self):
        if self.audioplayer.src:
            self.audioplayer.pause()
        self.state = "PAUSED"
        change_icon_image(document.getElementById("audio-ebook-bt-toggle"), "play")

    def toggle(self):
        if self.state is "PLAYING":
            self.pause()
        elif self.state is "PAUSED":
            self.play()

    def overlay(self):
        if self.overlay_off:
            self.overlay_off = False
            self.container.style.height = "calc(100% - 1em)"
            change_icon_image(document.getElementById("audio-ebook-bt-overlay"), "overlay-off")
        else:
            self.overlay_off = True
            self.container.style.height = "3ex"
            change_icon_image(document.getElementById("audio-ebook-bt-overlay"), "overlay-on")
            
    def on_container_clicked(self, ev):
        if ev.button is not 0:
            return
        ev.stopPropagation(), ev.preventDefault()
        margins = get_margins()
        pos = {"x": ev.clientX, "y": ev.clientY}
        pos = map_to_iframe_coords(pos, margins)
        self.send_message("play", pos=pos)

    def on_keydown(self, ev):
        ev.stopPropagation(), ev.preventDefault()
        if ev.key is "Escape":
            self.hide()
            return
        if ev.key is " " or ev.key is "MediaPlayPause" or ev.key is "PlayPause":
            self.toggle()
            return
        if ev.key is "Play" or ev.key is "MediaPlay":
            self.play()
            return
        if ev.key is "Pause" or ev.key is "MediaPause":
            self.pause()
            return
        sc_name = shortcut_for_key_event(ev, self.view.keyboard_shortcut_map)
        if not sc_name:
            return
        if sc_name is "show_chrome":
            self.hide()
        elif sc_name is "quit":
            self.hide()
        elif sc_name in ("up", "down", "pageup", "pagedown", "left", "right"):
            self.send_message("trigger-shortcut", name=sc_name)
    
    def findSpanIDForTime(self, currentTime):
        if self.audioMap:
            for spanID in self.audioMap[0]:
                clipBeginTime = self.convertTimeToSeconds(self.audioMap[0][spanID]["clipBegin"])
                clipEndTime = self.convertTimeToSeconds(self.audioMap[0][spanID]["clipEnd"])               
                if clipBeginTime <= currentTime < clipEndTime:
                    return spanID
        return None

    def convertTimeToSeconds(self, timeString):
        parts = timeString.split(":")
        if len(parts) != 3:
            return 0
        hours, minutes, seconds = map(float, parts)
        return hours * 3600 + minutes * 60 + seconds

    def secondsToMS(self, seconds):
        minutes = Math.floor(seconds / 60)
        remainingSeconds = int(seconds % 60)
        return str(minutes) + ':' + (str(remainingSeconds).zfill(2))

    def send_message(self, type, **kw):
        self.view.iframe_wrapper.send_message("audio-ebook", type=type, **kw)

    def handle_message(self, msg):
        if msg.type is "report-spanID":
            if msg.spanID:
                old_spanID = self.spanID
                self.spanID = msg.spanID
                self.send_message("mark", old_spanID=old_spanID, spanID = self.spanID)
                self.audioplayer.currentTime = self.convertTimeToSeconds(self.audioMap[0][self.spanID]["clipBegin"])
                self.play()